import pandas as pd
import argparse
import os

# ==============================================================
# Script: CSV Simplifier
# Description:
#   This script reads a .csv file generated by a GenBank intersection or
#   percentage tool, then produces a simplified table focusing on Pocket-based
#   rows (e.g. Pocket01, Pocket02, etc.) and other annotations (e.g. DGsite*),
#   taking the maximum of symmetrical entries in the original CSV. Finally, it
#   sorts the resulting table so that:
#     1) The Pocket rows are sorted in descending order by their maximum
#        intersection value (across columns).
#     2) The annotation columns (e.g. DGsite*) are sorted in descending order
#        by their maximum intersection value (across all Pocket rows).
#
# Usage:
#   python CSV_Simplifier.py <input_csv> <pocket_base> <output_csv>
#
# Example:
#   python CSV_Simplifier.py ADSS2_relative.csv Pocket ADSS2_simple.csv
#
# Steps:
#   1. Reads ADSS2_relative.csv.
#   2. Filters rows containing the substring "Pocket" in the index.
#   3. Filters columns that do NOT contain "Pocket" (e.g. DGsite columns).
#   4. Keeps total residues for pockets in the second column.
#   5. Keeps total residues for non-pocket columns in the top row.
#   6. Each cell is the max between df.loc[pocket, annotation] and df.loc[annotation, pocket].
#   7. Sorts pocket rows (descending) by their maximum intersection across annotation columns.
#   8. Sorts annotation columns (descending) by their maximum intersection across pocket rows.
#   9. Writes out ADSS2_simple.csv.
# ==============================================================

def main():
    parser = argparse.ArgumentParser(description="Simplify an intersection CSV file by focusing on pockets and other annotations, then sorting by maximum intersection values.")
    parser.add_argument("input_csv", help="Path to the input CSV file (intersection table)")
    parser.add_argument("pocket_base", help="Substring that identifies pocket rows (e.g. 'Pocket')")
    parser.add_argument("output_csv", help="Path to the simplified CSV file")
    args = parser.parse_args()

    if not os.path.isfile(args.input_csv):
        print(f"Error: input file '{args.input_csv}' does not exist.")
        return

    df = pd.read_csv(args.input_csv, index_col=0)

    # Separate out the total-residues row if it exists
    total_residues_row = None
    if "Total Residues" in df.index:
        total_residues_row = df.loc["Total Residues"].copy()
        df = df.drop(index="Total Residues")

    # Separate out the total-residues column if it exists
    column_residues = None
    if "Total Residues" in df.columns:
        column_residues = df["Total Residues"].copy()
        df = df.drop(columns="Total Residues")

    # Identify pocket rows
    pocket_rows = [idx for idx in df.index if args.pocket_base in idx]
    # Identify annotation columns (no pockets)
    annotation_cols = [col for col in df.columns if args.pocket_base not in col]

    # Build a simplified DataFrame with columns:
    #   ["PocketName", "TotalResidues"] + annotation_cols
    new_columns = ["PocketName", "TotalResidues"] + annotation_cols
    simplified_df = pd.DataFrame(columns=new_columns)

    # Build dicts to hold total-residues info for pockets & annotations
    annotation_col_totals = {}
    if total_residues_row is not None:
        for col in annotation_cols:
            annotation_col_totals[col] = total_residues_row.get(col, "")

    pocket_row_totals = {}
    if column_residues is not None:
        for p in pocket_rows:
            pocket_row_totals[p] = column_residues.get(p, "")

    # Fill simplified_df with data
    for p in pocket_rows:
        row_dict = {}
        row_dict["PocketName"] = p
        row_dict["TotalResidues"] = pocket_row_totals.get(p, "")
        for col in annotation_cols:
            val1 = 0
            val2 = 0
            if p in df.index and col in df.columns:
                val1 = df.loc[p, col]
            if col in df.index and p in df.columns:
                val2 = df.loc[col, p]
            row_dict[col] = max(val1, val2)
        simplified_df = simplified_df.append(row_dict, ignore_index=True)

    # Create a header row for annotation columns containing total residues
    header_row = {c: "" for c in new_columns}
    for col in annotation_cols:
        header_row[col] = annotation_col_totals.get(col, "")

    final_rows = [header_row] + simplified_df.to_dict("records")
    final_df = pd.DataFrame(final_rows, columns=new_columns)

    # The top-left corner entries 
    final_df.iloc[0, 0] = "Total Residues"  
    final_df.iloc[0, 1] = ""  

    # Convert annotation columns to numeric in the body (row 1..)
    body_df = final_df.iloc[1:].copy()
    annotation_cols_only = new_columns[2:]  # annotation columns

    # Convert them to numeric where possible
    for col in annotation_cols_only:
        body_df[col] = pd.to_numeric(body_df[col], errors='coerce').fillna(0)

    # ----------------------------------------------------
    # Sort columns by max intersection (descending)
    # We'll skip row 0, so we consider body_df only.
    # For each column c in annotation_cols_only, find max.
    col_max = body_df[annotation_cols_only].max(axis=0)
    col_sorted = col_max.sort_values(ascending=False).index.tolist()

    # Reorder final_df's columns to keep the first two in place
    reorder_cols = ["PocketName", "TotalResidues"] + col_sorted
    final_df = final_df[reorder_cols]

    # Next, reorder pocket rows by max intersection (descending)
    row0 = final_df.iloc[[0]]
    body = final_df.iloc[1:].copy()

    for c in col_sorted:
        body[c] = pd.to_numeric(body[c], errors='coerce').fillna(0)

    # For each row, find the max across these annotation columns.
    row_max_vals = body[col_sorted].max(axis=1)
    row_sorted_index = row_max_vals.sort_values(ascending=False).index
    body = body.loc[row_sorted_index]

    final_df = pd.concat([row0, body], ignore_index=True)

    # Save to CSV
    final_df.to_csv(args.output_csv, index=False)

    print(f"Simplified & sorted CSV saved to {args.output_csv}")

if __name__ == "__main__":
    main()
